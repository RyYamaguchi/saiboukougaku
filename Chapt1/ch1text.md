#ImageJ定量階梯　第1回

監修：塚田祐基、三浦耕太

第一回担当：三浦耕太（欧州分子生物学研究所）

## はじめに

1665年にフックが複式顕微鏡を発明し細胞を発見してから、生物学者は顕微鏡を覗きこみミクロの世界を精緻に描いてきた。19世紀のドイツの生物学者エルンスト・ヘッケルの"Kunstformen der Natur"という美しいスケッチ集をご存知の方も多いだろう。やがて20世紀初頭には写真術が融合し生物を写真におさめる技術が発達した。20世紀後半になるとコンピュータが顕微鏡技術と融合し、デジタル画像が用いられるようになり、さらにはライブイメージングによる動画像の取得が一般的になってきた。こうした歴史を鑑みれば、生物学と画像は常に切っても切れない関係にあってきたといえる。とはいえ、計算機を用いる画像工学と融合したことにより、画像の定量という意味で大きな質的転換が起きた。このことで生じた新たなアプローチはあまたある。次にその主なものを挙げてみよう。

- 多次元画像の可視化と解析
- 形態のダイナミクスにおける定量的な遡行
- 「よく撹拌」されていない生化学とそのモデリング
- 超解像度解析による一分子の分布や動態の可視化
- 画像データの大規模化と解析の自動化

生物のシステムが空間的に展開する動的なシステムであることは議論をまたない。その動的な特徴を画像のまま捉え、空間のコンテキストを削らずに解析することが今や可能となり、アクチンフィラメントの動態や、ゼブラフィッシュの細胞レベルでの網羅的発生ダイナミクスなど、「動的な仕組み」に迫る生物学が精力的に進められている（Danuser, 2011）。

こうした飛躍的な発展がある一方で、画像解析そのものに敷居の高さを感じているという生物研究者をよく見かけるようになった。これはおそらく生物学においていまだに画像解析や画像処理が測定技術として体系化されておらず、どのように学べばよいのかがわかりにくいことがその大きな理由であると思われる。たとえば化学においては分析化学という測定のための体系がある。一方、生物画像の定量という点においてはどうだろうか。**画像処理**の教科書は数多く出版されているが、**生物画像定量**のための教科書は英語も含めて現在ほとんど存在しない。そこで本連載では生物画像の定量解析を読者が自ら学ぶための記事を提供したいと考えている。

Computer vision in cell biology. Danuser G. Cell. 2011 Nov 23;147(5):973-8

## ImageJと画像処理・解析

さて、画像はデータである。“データ“というと数字の羅列というイメージがなんとなくあるかもしれないが、顕微鏡を使って取得したサンプルのデジタル画像もまた数値データである。画像を単に眺めるだけならあまたある画像ビューアーを使えば十分だが、二次元の数値データとして画像から生物学的に意味のある情報を抽出しようとしたり、さらに時系列や三次元の画像を解析するためには特殊な機能が要請される。ImageJはそうした科学的な画像解析のためのソフトである。NIHにいたWayne Rasbandが15年ほどまえに開発を始め、オープンソースであることから多くの研究者が開発に参入していった。今や生物学のイメージング分野ではデファクトスタンダードとなっており、いまでも日々その開発は続いている。

ImageJがポピュラーになった大きな理由のひとつは、プラグインとして自分で機能を追加できることにある。研究で使われるソフトには、使いやすさという点での一般性と、プロジェクトに応じて必要になる特殊性の矛盾した二面性を持っている必要があるが、ImageJではプラグインによって特殊性という面を担保している。いわば、モジュラリティによって一般性と特殊性の矛盾を解消している、といえるだろう。世界中でさまざまなプラグインが開発され、研究者はこれらのプラグインをそれぞれの目的にしたがって組み合わせながら使ってきた。やがてプラグインの間での複雑な依存関係が生じるようになり、こうした依存性の問題を解決するために多くのプラグインや画像処理関係のライブラリをあらかじめ追加したFijiなどのディストリビューションの開発も始まった。FijiのコアはImageJに他ならないが、複数のプラグインの更新を個別に行うのではなく、依存関係に応じて自動的にアップデートするメカニズムが搭載されている。モジュラーなシステムの欠点であるバージョン管理の煩雑さをこのことで解決し、さらに多くの開発者たちがそれぞれ開発を続けながらも、その依存関係を保つように設計されている。このことでFijiは多くの開発者たちの共同作業のプラットフォームともなっている。

すでにImageJやFijiを使ったことのある人は読者にも多いであろうが、多岐にわたる機能を十分に使いこなしている人は少ないだろう（ImageJのバージョン1.48bにはメニューの項目が505ある）。この連載はImageJの実践的な使い方を伝授し、読者がその機能を駆使するようになることを目標としている。とはいえ手順を覚えるだけではフォトショップと変わらない。画像を科学データとして扱うためには画像処理の原理を知っている必要がありそのことで応用も広がる。したがってこれらの基礎的な面について解説しながら徐々に高度な処理を行えるように展開してゆくつもりである。今しばらくは生物学的に興味のある内容ではないのでこの点ご容赦願いたい。また、高度な解析にはどうしてもある程度のプログラミングが必要になる。プログラミングができない人にも解読できる程度の短いスクリプトも紹介し、それぞれの目的にあった解析に応用して欲しい。

読者は各自のパソコンにFijiをインストールしていることを想定している。もしインストールしていない場合は、Fiji以下のサイトからダウンロードしてインストールしてほしい。

<http://fiji.sc>

インストールの仕方がわからない、という方はこちらのページを参照に。

[Fijiのインストール手順]()（準備中）

Fijiのアイコンをクリックして図1のようなメニューバーが表示されれば、インストールは成功である。

図1　Fijiのメニューバー。
![Menu](img/FijiMenu.png)


[1] Schneider, C. A., Rasband, W. S., & Eliceiri, K. W. (2012). NIH Image to ImageJ: 25 years of image analysis. Nature methods, 9(7), 671–5. PMID:22930834

##テキストエディタを使った画像処理

デジタル画像データの真の姿は数字のマトリクスである。このことを実感してみよう。まず新しい画像を作成し、その画像の本来の姿である数字のマトリクスをテキストエディタで眺めることにする。さらにこの数字をテキストエディタで編集し、逆にそれを画像に戻してみることにする。この演習はテキストエディタで画像処理を行うことに相当する。

**演習　1**：新しい画像をます作成する。Fijiのメニューから[File > New > Image…]を選択すると、入力ウィンドウが表示される（図2）。次のようにパラメータを入力し、OKのボタンをクリックする。

* Name: test.txt
* Type: 8-bit
* Fill with: Black
* Width: 10
* Height: 15
* Slices: 1


図2　新しい画像を作成するときの入力ウィンドウ。

![NewFile](img/NewFileDialog.png)

すると黒いバックグラウンドの画像のウィンドウが表示される。画像はかなり小さいので、キーボードの＋を何度か押し拡大するとよい（逆に小さくする場合は−のキーを押す）。この画像を[File > Save As > Text Image] によってデスクトップに保存する。ファイルの拡張子が.txtであることを確認し（OSの設定によってはファイルの拡張子が隠されていることがある。この場合は「情報」などで確認する）、そのファイルをダブルクリックするとテキストエディタでファイルが開かれる。スペースで区切られた碁盤目状の数字を確認できるだろう。このそれぞれの数字が1ピクセルごとの輝度に相当する。真っ黒な画像なので、数字はすべて0のはずである（図3）。

図3　テキストエディタ（OSXのデフォルトはTextEdit, WindowsではNotepad）で開いた画像。

![TextEdit](img/textedit.png)

さて、どれでもよいのでいくつかの0を255に書き換えてみよう。数字の間のスペースを削除しないように注意する。書き換えたらファイルをtest2.txtなどの別名でデスクトップに保存する。Fijiに戻って[File > Import > Text Image…]をメニューから選択し、先ほどテキストエディタで編集したファイルを開くように指定する。こうして開かれた画像は、0を255に置き換えた場所が白い点になっているはずである。0が黒、255が白のピクセルとして表示されていることが実感できれば幸いである。

以上、テキストエディタによる画像処理を紹介した。ImageJが行っている画像処理はすべてこのように画像の真の姿である数字のマトリクスに対して計算を行っている。以降、このことを常にイメージしながら作業を行うことをおすすめする。

なお、開いている画像の特定の位置のピクセル輝度を知りたい場合には、その位置にマウスのポインタを置くと、メニューバーの左下の隅にその位置の座標と輝度が表示される（図4）。

図4　メニューバーに表示されるピクセルの値

![Pixel value in menu](img/PixelValueInMenu.png)


ピクセル輝度をマトリクスとして表示したい場合には[Image > Transform > Image to Results]を実行すると、新たなウィンドウが開き、画像を数値として眺めることができる（図5）。ただし編集することはできない。

図5　ピクセル値を表に表示する

![Pixel values in results](img/PixelValueInResults.png)


##画像のビット深度

上の演習ではテキストエディタで0を255に書き換えた。なぜ255であったのか。この疑問に答えるには、ビット深度について理解する必要がある。

それぞれの画像を構成するピクセルはある特定の値を持っている。グレースケールの画像であれば、この値は黒から白までの間のある特定の明るさに相当することになる。黒から白の間には無限の階調があるはずであるが、コンピュータ上では黒と白の間の濃淡を有限の数で分割してピクセルの値に対応させる。単純には黒と白の二つだけに分割する。これを2階調（Binary）、あるいはより日常的には“白黒“と呼ばれる。この場合ピクセルの値は単に0か1かということで十分であり、二進数にして一桁（1ビット）で各ピクセルの値を指定すれば十分である（図6）。

白黒だけではなく中間の灰色を表示するためには階調を増やし、例えば4階調にする。こうすると薄い灰色と濃い灰色を白と黒の間に表示することができる。0から3までの4種類の値があればすべての階調を指定することが可能であり、二進数では二桁の数で表現することができる。よってこれは2ビット画像というこになる。4階調ではなめらかな明るさの変化を表現することはできない。よりなめらかに明暗を表示するには階調をさらに増やす必要があり、このため最も頻繁に使われるのが256階調である。256を2進数で表現すると8桁の数字（$$$2^8$$$）となるので256階調の画像は8ビット画像である。より手短に言えば、1ピクセルに8ビット分のメモリを割り当てることで256階調を実現しているのである。

図6　ビット深度と階調数。

![bitdepth](img/bitdepth.png)

この1ピクセルあたりに割り当てられているメモリの量をさして、ビット深度（bit depth）と呼び、8ビット画像の場合ピクセルの値は0から255までの整数をとる。上の演習で255に置き換えたのは、それが8ビットの画像でとりうる最大の値だからである。16のビット深度を持つ画像は$$$2^{16}$$$すなわち65,336の階調を持つ。白と黒の間をより細かく分割するので量子化誤差が小さくなる。なお普通の人間が認識できる階調の精度は8ビット以下なので、8ビットと16ビットのグレースケール画像の見た目は変わらない。また、二倍のメモリを各ピクセルに割り当てることになるので、ファイルのサイズもおよそ二倍になる。

以上紹介したビット深度はいずれも正の整数をピクセルの値としてもつが、正負の実数をピクセル値として保持することができるのが、32ビット浮動小数点画像である。ImageJでは単に32-bitとして名前がつけられている。32桁の容量を整数と一対一対応させるのではなく、指数表現で対応させる。ひと桁を正負の符号に、あとの桁を8桁の指数部と23桁の仮数部にわけて実数を表現する。ピクセルの値に実数を持たせることができると、さまざまな利点がある。たとえば、割合画像法（ratio imaging）で行われるように画像間の割り算を行った場合、8ビットや16ビットの画像では計算結果の小数点以下は切り捨てられてしまうが、32ビット画像で計算すれば小数点以下の値を持つ結果を得ることができる。

**演習　2**：16ビット画像の8ビットへの変換

画像のビット深度の違いは、ビット深度を変換しようとしたときに特にそれを実感することができる。まずサンプルの画像を[File > Sample Images > M51 GALAXY (177k, 16-bits)]で開いてみよう（開くにはインターネットに接続している必要がある）。この画像は16ビット画像である。この画像を二種類の方法で8ビット画像に変換し、結果の違いを輝度プロファイルで比較する。輝度プロファイルはある選択した線に沿ったピクセルの値をプロットした曲線である。

輝度プロファイルは次のようにして取得する。Fijiのメニューバーから線選択（line selection tool）のアイコン（左端から4番目の斜めの線のアイコン）をクリックして選び、上で開いた画像の明るい部分を通るように黄色の直線を描く（図7）。始点と終点をクリックすれば直線が描かれるはずである。次にメニューから[Analyze > Plot Profile]を選択すると、横軸が（距離）Distance、縦軸が輝度（Gray value）のプロットが表示されるはずである（図8）。

図7　m51.tifの画像に線選択ツールで線選択を行う。

![Line Selection](img/m51_LineRoi.png)

図8　輝度プロファイルのプロット

![ProfilePlot](img/profile16bit.png)


次のようにして三種類の輝度プロファイルを得る。

 1. 変換せずに16ビット画像のまま輝度プロファイルをえる。

 2. メニューから[Image > Duplicate] を選んで画像を複製する。[Edit > Option > Conversion]を選び、"Scale when converting"をチェックする。次に複製した画像が一番上にある（アクティブな画像と呼ぶ）ことを確認し、[Image > Type > 8-bit]を選び、ビット深度を8ビット画像に変換する。[Edit > Selection > Restore Selection]を選ぶ。1で描いたのと同じ位置に黄色い線が現れるはずである。この状態で[Analyze > Plot Profil]を選ぶと、2つ目の輝度プロファイルが表示される。

 3. 元々の16ビットの画像をアクティベート（画像のウィンドウをクリックする）し、再び[Image > Duplicate] によって複製する。[Edit > Option > Conversion]を選び、"Scale when converting"のチェックを外す。あとは2と同じような方法で、これまでと同じ位置から輝度プロファイルを得る。これが3番目の輝度プロファイルである。
 
図9　正規化のオプションを変更するウィンドウ。この場合は"Scale When Converting"がチェックされているので正規化してビット深度の変換が行われる。

![Scaling Option](img/scalingoption.png)


3つの輝度プロファイルを比較すると次のようなことがわかるだろう。まず1番目と2番目の輝度プロファイルの形が極めて似ていることである。とはいえ、縦軸の目盛を比較すると、レンジがことなっていることがわかる。3番目の輝度プロファイルはこれらのプロファイルとはだいぶ形がことなっている。"Scale when converting"は、変換の際に値を正規化するかどうかを決定するオプションである。最初の変換では値が8ビットの深度に正規化されるが、二番目の変換では正規化をしないように選択したことになる。正規化が行われない場合、16ビットの画像で256以上だった値はすべて255の値になる。画像を眺めると、正規化をしなかった変換の場合、画像の多くの部分がサチっているのがわかるだろう。

16ビットから8ビットへの変換は情報量を削減することになる。デフォルトの設定では正規化がオンになっているが、見た目だけで正規化が行われていることに気がつくのは難しいだろう。

この演習がおわったら、オプションの"Scale when converting"のチェックをオンにして、デフォルトの状態に戻しておくことをおすすめする。

##宿題

この連載では毎回宿題を課す。回答は次回示すこととする。

1. 4ビット画像はいくつの階調を持つか？
2. 横幅100ピクセル、縦100ピクセルの8ビット画像のファイルサイズを推定せよ。推定の根拠も説明せよ。画像のフォーマットはbitmap（bmp）とする。


##スクリプトによるピクセル値へのアクセス

さて、ここからはImageJのマクロをつかって各ピクセルの値にアクセスする方法を解説する。次の二つの作業を試みる。（1）画像の特定のピクセル値を取得したり書き換えたりする。これは基礎中の基礎、といえるだろう。（2）演習2で行った輝度プロファイルの取得をスクリプトから試み、ガウス分布のフィッティングにより輝点の中心座標を推定する。点光源のシグナルの位置を超解像度で推定するには、2次元ガウス分布のフィッティングがしばしばおこなわれる。このスクリプトはその1次元バージョンである。

なお、それぞれの詳しいコマンドのマニュアルはImageJのサイトにあるので、そちらも参照にされたい。

<http://imagej.nih.gov/ij/developer/macro/functions.html>

プログラミングの基礎は誌面の都合上詳しく行うことはできないが、全く理解出来ない、という方は以下のリンクからダウンロードできる英語の教科書"Macro Programming in ImageJ"の2.2章と2.3章を自習することをお勧めする。

<http://cmci.embl.de/documents/ijcourses>


### 画像の特定のピクセル値を取得して書き換える

特定の座標のピクセル値を得るには関数``getPixel``を用い、ピクセル値を画像に書き込むには``setPixel``を用いる。画像m51.tifを再び開いてみよう（[File > Sample Images > M51 GALAXY (177k, 16-bits)]）。次にスクリプトエディタを[File > New > Script]によって開く。スクリプトエディタのメニューから、[Language > ImageJ Macro]を選んで言語を設定し、次の2行のコードを書く。

```
val = getPixel(100, 150);
print(val);
```

左下の"Run"というボタンをクリックするとスクリプトが実行される。Logウィンドウが開き、そこに"381"と表示されるはずである。これは、まず一行目で画像内の座標(100, 150)のピクセル値を変数valとして取得し、次にその変数の値をprintコマンドによってログウィンドウに出力している。このピクセルの値を書き換えるには、さらに次の2行を加える。

```
setPixel(100, 150, 30000);
updateDisplay();
```


図10 スクリプトエディタに4行のコードを書き終えたところ。
![Script Editor](img/scripteditor.png)


Runにより実行し、画像を確認すると、座標(100, 150)のピクセルが白い点になっていることがわかるだろう。ピクセル値が30000になっていることも、マウスのポインタをその位置に移動して確認してみよう。

さらにループを使って横一文字の点線を引いてみる。スクリプトエディタで[File > New]を選んで新しいスクリプトを用意し、言語をふたたびImageJ Macroに設定する([Language > ImageJ Macro])。次の二行を書く。

```
for (i = 0; i < getWidth(); i += 1){
	setPixel(i, 150, 30000);
}
```

forループの条件に現れる``getWidth()``は、画像の横幅をピクセル数で取得するコマンドである。また、このコードでは使われていないが、縦の高さは``getHeight()``によって取得できる。画像の座標系は左上のコーナーが(0, 0)であり、右下の座標が(getWidth()-1, getHeight()-1)である。上記のコードのループは画像の右端のピクセルから左端のピクセルまでループし、`y = 150``にあるピクセルの値をすべて30000に書き換える。

###スクリプトの宿題

上の例では水平の実線を描いた。垂直な点線を描くスクリプトを書いてみよ。

### 輝度プロファイルを取得し、ガウス分布をフィッティングする

画像m51.tifを再び開き（[File > Sample Images > M51 GALAXY (177k, 16-bits)]）、演習2で行ったように中央の明るい部分を通るline selectionを行う。この状態で以下のマクロを実行せよ。

```
pf = getProfile();
xs = newArray(pf.length);
for (i = 0; i < xs.length; i += 1)
	xs[i] = i;
Fit.doFit("Gaussian", xs, pf);
Fit.plot;
```

一行目は関数``getProfile()``を使っている。この関数はアクティブな画像で選択されているline selectionに沿った輝度プロファイルを、ー次元の配列(Array)として返す。上のスクリプトではこの配列を変数pfとしている。なお、pfの要素の数はpf.lengthとすると取得できる。

フィッティングをするにはこのy軸の値だけではなくx軸の値も必要となるのでこれを用意するのが2行目から4行目までである。2行目では取得した輝度プロファイルと同じ長さの配列を``newArray``関数を使って配列xsとして用意する。初期値は0なので、3行目から4行目までのループで配列の要素の値をそれぞれ0,1,2,… xs.length-1と書きこむ。

5行目で関数``Fit.doFit``関数によってガウス分布のフィッティングを行い、6行目の``Fit.plot``によりその結果を表示する。

図11　ガウス分布をフィッティングした結果の表示例

![Gauss Fit results](img/GaussfitPlot.png "輝度プロファイルのフィッティングの結果")








